### 冒泡排序
时间复杂度：O(^2)

```python
# 最大元素排在末尾
def bubbleSort(list):
    if len(list) < 2 or list == None:
        return
    for i in range(len(list) - 1):
        # 计较次数
        for j in range(0, len(list) - 1 - i):
            if list[j] > list[j + 1]:
                list[j], list[j + 1] = list[j + 1], list[j]
    return list

```

### 选择排序

时间复杂度：O(^2)
```python
# 最大元素排在末尾
def selectiveSort(list):
    if list == None or len(list) < 2:
        return
    for i in range(len(list) - 1):
        # 假设第一个数最小
        min_idx = i
        # list[min_idx] 需要与其之后的所有数字进行比较
        for j in range(i+1, len(list)):
            if list[min_idx] > list[j]:
                min_idx = j
        list[i], list[min_idx] = list[min_idx], list[i]
    return list


```

### 插入排序

时间复杂度：O(^2)，最好为O(n)
```python

# 最大元素排在末尾
def InsertionSort(list):
    if list == None or len(list) < 2:
        return
    for i in range(1, len(list)):
        # 将拿到的元素放到前面有序序列中正确位置的过程
        for j in range(i, 0, -1):
            # 如果比前面的元素小，交换
            if list[j - 1] > list[j]:
                list[j], list[j - 1] = list[j - 1], list[j]
            # 否则代表比前面的所有元素都大，内循环结束
            else:
                break
    return list

```

## 归并排序

利用分治策略实现,先递归分解数组，再将其合并

```python
# 最大元素排在末尾
def mergeSort(list):
    # 递归返回条件
    if len(list) == 1:
        return list

    mid = len(list) // 2

    left = mergeSort(list[:mid])
    right = mergeSort(list[mid:])

    return merge(left, right)

# 将两个有序数组合并，需要申请一个辅助数组
def merge(left, right):
    l, r = 0, 0
    result = []

    while l < len(left) and r < len(right):
        if left[l] < right[r]:
            result.append(left[l])
            l += 1
        else:
            result.append(right[r])
            r += 1

    result += left[l:]
    result += right[r:]
    return result

# for test
list = list(np.random.randint(1, 10, 30))

result1 = sorted(list)
result2 = mergeSort(list)

if result1 == result2:
    print('true')
```
